This file describe all the Keepalived available keywords. The keepalived.conf
file is compounded by three configurations parts :

	* Globals configurations
	* VRRP configuration
	* LVS configuration

0. Comment string

There is 2 valid comment valid string : # or ! If you want to add comment
in you configuration file use this char.

0.1. Parameter syntax

<BOOL> is one of on|off|true|false|yes|no

0.2. Conditional configuration and configuration id

Any configuration line starting with '@' is a conditional configuration line.
The word immediately following (i.e. without any space) the '@' character
is compared against the string specified with the -i command line option,
or if none specified, the first part of the node name as returned by uname,
and if they don't match, the configuration line is ignored.

The purpose of this is to allow a single configuration file to be used for
multiple systems, where the only differences are likely to be the router_id,
vrrp instance priorities, and possibly interface names.

For example:

global_defs
{
@main	router_id main_router
@backup router_id backup_router
}

If keepalived is invoked with -i main, or if -i is not specified and the node
name is main.SOMETHING, then the router_id will be set to main_router,
if invoked with -i backup, or the node name is backup, then backup_router,
if not invoked with -i and the node name is not main or backup, or with
-i anything else, then the router_id will not be set.

0.3. Scripts

There are three classes of scripts can be configured to be executed.

a. Notify scripts that are run when a vrrp instance or vrrp group changes state,
   or a virtual server quorum changes between up and down.

b. vrrp tracking scripts that will cause vrrp instances to go down it they exit
   a non-zero exist status, or if a weight is specified will add or subtract the
   weight to/from the priority of that vrrp instance.

c. LVS checker misc scripts that will cause a real server to be configured down
   if they exit with a non-zero status.

By default the scripts will be executed by user keepalived_script if that user
exists, or if not by root, but for each script the user/group under which it is
to be executed can be specified.

There are significant security implications if scripts are executed with root
privileges, especially if the scripts themselves are modifiable or replaceable
by a non root user. Consequently, security checks are made at startup to ensure
that if a script is executed by root, then it cannot be modified or replaced by
a non root user.

All scripts should be written so that they will terminate on receipt of a SIGTERM
signal. Scripts will be sent SIGTERM if their parent terminates, or it is a script
the keepalived is awaiting its exit status and it has run for too long.

1. Globals configurations

This block is divided in 4 sub-blocks :

	* Global definitions
	* Static addresses
	* Static rules
	* Static routes

	1.1. Global definitions

	The configuration block looks like :

global_defs {				# Block identification
    notification_email {		# Email address to send alerts to
       <EMAIL ADDRESS>			# Standard email address
       <EMAIL ADDRESS>
       ...
    }
    notification_email_from <EMAIL ADDRESS> # Email From dealing with SMTP proto
					   #   defaults to keepalived@<local host name>
    smtp_server <ADDRESS>|<DOMAIN_NAME>	[<PORT>]
					   # SMTP server IP address or domain name
					   #  with optional port number (defaults to 25)
    smtp_helo_name <HOST_NAME>		   # name to use in HELO messages
					   #  defaults to local host name
    smtp_connect_timeout <INTEGER>	   # Number of seconds timeout connect
 					   #  remote SMTP server
    router_id <STRING>			   # String identifying router
    vrrp_garp_interval <DECIMAL>           # Sets the default interval between Gratuitous ARP
					   #   (in seconds, resolution microseconds)
    vrrp_gna_interval <DECIMAL>            # Sets the default interval between unsolicited NA
					   #   (in seconds, resolution microseconds)
    vrrp_mcast_group4 <IPv4 ADDRESS>	   # optional, default 224.0.0.18
    vrrp_mcast_group6 <IPv6 ADDRESS>	   # optional, default ff02::12
    default_interface <INTERFACE>	   # sets the default interface for static addresses, default eth0
    lvs_sync_daemon <INTERFACE> <VRRP_INSTANCE>	[id <SYNC_ID>] [maxlen <LEN>] [port <PORT>] [ttl <TTL>] [group <IP ADDR>]
					   # Binding interface, vrrp instance and optional
					   #  syncid (0 to 255) for lvs syncd
					   #  maxlen (1..65507) maximum packet length
					   #  port (1..65535) UDP port number to use
					   #  ttl (1..255)
					   #  group - multicast group address (IPv4 or IPv6)
					   # NOTE: maxlen, port, ttl and group are only available on Linux 4.3 or later.
    lvs_flush				   # flush any existing LVS configuration at startup
    vrrp_garp_master_delay <INTEGER>	   # delay in seconds for second set of gratuitous ARP
					   #  messages after MASTER state transition, default 5.
					   #  0 means no second set.
    vrrp_garp_master_repeat <INTEGER>	   # how many gratuitous ARP messages after MASTER
					   #  state transition should be sent, default 5
    vrrp_garp_lower_prio_delay <INTEGER>   # delay for second set of gratuitous ARPs after lower
					   #  priority advert received when MASTER
    vrrp_garp_lower_prio_repeat <INTEGER>  # number of gratuitous ARP messages to send at a time
					   #  after lower priority advert received when MASTER
    vrrp_garp_master_refresh <INTEGER>	   # Periodic delay in seconds sending
					   #  gratuitous ARP while in MASTER state
					   #  Default: 0 (no refreshing)
    vrrp_garp_master_refresh_repeat <INTEGER> # how many gratuitous ARP messages should be sent
					   #  at each periodic repeat
					   #  Default: once (per period)
    vrrp_lower_prio_no_advert [<BOOL>]     # If a lower priority advert is received, just discard
					   # it and don't send another advert. This causes adherence
					   # to the RFCs.
    vrrp_version <INTEGER:2..3>            # Default VRRP version (default 2)
    vrrp_iptables [keepalived_in [keepalived_out]]     # default INPUT
					   # Specifies the iptables chains to add entries to
					   # If no table names are specied, no entries are added
    vrrp_ipsets ipset4 [ipset6 [ipset_if6]] # Set the ipset set names to use. If no names are specied,
					   #   ipsets will not be used.
					   # If ipset6 is not specified, '6' as appended to the ipset4 name
					   #   if ipset_if6 is not specified, any trailing '6' from ipset6
					   #   is removed and '_if6' appended
    vrrp_check_unicast_src		   # Check source address of a unicast packet is a
					   # unicast peer
    vrrp_strict				   # Enforce strict VRRP protocol compliance. This will prohibit:
					   #   0 VIPs
					   #   unicast peers
					   #   IPv6 addresses in VRRP version 2
					   # Sets:
					   #   vrrp_lower_priority_dont_send_advert
					   #
					   # The following 4 options can be used if vrrp or checker processes
					   #   are timing out. This can be seen by a backup vrrp instance becoming
					   #   master even when the master is still running, due to the master or
					   #   backup systems being busy, they are not processing the vrrp packets.
    vrrp_priority <INTEGER:-20..19>	   # Set the vrrp child process priority (negative values increase priority)
    checker_priority <INTEGER:-20..19>	   # Set the checker child process priority
    vrrp_no_swap			   # Set the vrrp child process non swappable
    checker_no_swap			   # Set the checker child process non swappable
					   #
					   # If keepalived has been build with SNMP support,
					   #   the following keywords are available
					   # Note: keepalived, checker and rfc support can be
					   #   individually enabled/disabled
    snmp_socket <PROTOCOL>:<ADDRESS>[:<PORT>] # specify socket to use for connecting to SNMP master agent (default unix:/var/agentx/master)
					   #   unless using a network namespace, when the default is udp:localhost:705
    enable_snmp_keepalived		   # enable SNMP handling of vrrp element of KEEPALIVED MIB
    enable_snmp_checker			   # enable SNMP handling of checker element of KEEPALIVED MIB
    enable_snmp_rfc			   # enable SNMP handling of RFC2787 and RFC6527 VRRP MIBs
    enable_snmp_rfcv2			   # enable SNMP handling of RFC2787 VRRPv2 MIB
    enable_snmp_rfcv3			   # enable SNMP handling of RFC6527 VRRPv3 MIB
    enable_traps			   # enable SNMP trap generation
					   #
    enable_dbus				   # enable the DBus interface
					   #
    script_user USERNAME [GROUPNAME]	   # Specify the default username/groupname to run scripts under
					   # If groupname is not specified, the group of the user is used.
					   # If this option is not specified, the user defaults to keepalived_script
					   # if that user exists, otherwise root.
    enable_script_security		   # Don't run scripts configured to be run as root if any part of the path
					   # is writable by a non-root user.
}

net_namespace NAME			   # Set the network namespace to run in
					   # The directory /var/run/keepalived will be created as an unshared mount point,
					   #   for example for pid files.
					   # syslog entries will have _NAME appended to the ident.
					   # Note: the namespace cannot be changed on a configuration reload
namespace_with_ipsets			   # ipsets wasn't network namespace aware until Linux 3.13, and so if running with
					   # an earlier version of the kernel, by default use of ipsets is disabled if using
					   # a namespace and vrrp_ipsets isn't specified.
					   # This options overrides the default and allows ipsets to be used
					   # with a namespace on kernels prior to 3.13.

instance NAME				   # If multiple instances of keepalived are run in the same namespace, this will
					   #   create pid files with NAME as part of the file names, in /var/run/keepalived.
					   # Note: the instance name cannot be changed on a configuration reload

use_pid_dir				   # Create pid files in /var/run/keepalived

linkbeat_use_polling			   # Use media link failure detection polling fashion

	1.2. Static addresses

	The configuration block looks like :

static_ipaddress {			# block identification
					# If no dev element is specified, it defaults to the default_interface (default eth0)
    <IP ADDRESS>/<MASK> brd <IP ADDRESS> dev <STRING> scope <SCOPE>
    <IP ADDRESS>/<MASK> brd <IP ADDRESS> dev <STRING> scope <SCOPE>
    ...
}

SCOPE can take the following values :
	* site
	* link
	* host
	* nowhere
	* global

	1.3 Static rules

static_rules {							# block identification
								# The syntax is that same as for ip rule add, without "ip rule add"
								# with the addition of tunnel-id option, e.g.
	from 192.168.28.0/24 to 192.168.29.0/26 table small iif p33p1 oif wlan0 tos 22 fwmark 24/12 preference 39 realms 30/20
	to 1:2:3:4:5:6:7:0/112 from 7:6:5:4:3:2::/96 table 6908
}

	1.4. Static routes

	The configuration block looks like :

static_routes {							# block identification
								# The syntax is the same as ip route add, without "ip route add" e.g.
	192.168.100.0/24 table 6909 nexthop via 192.168.101.1 dev wlan0 onlink weight 1 nexthop via 192.168.101.2 dev wlan0 onlink weight 2
	192.168.200.0/24 dev p33p1.2 table 6909 tos 0x04 protocol bird scope link priority 12 mtu 1000 hoplimit 100 advmss 101 rtt 102 rttvar 103 reordering 104 window 105 cwnd 106 ssthresh lock 107 realms PQA/0x14 rto_min 108 initcwnd 109 initrwnd 110 features ecn
	2001:470:69e9:1:2::4 dev p33p1.2 table 6909 tos 0x04 protocol bird scope link priority 12 mtu 1000 hoplimit 100 advmss 101 rtt 102 rttvar 103 reordering 104 window 105 cwnd 106 ssthresh lock 107 rto_min 108 initcwnd 109 initrwnd 110 features ecn
}

2. VRRP configuration

This block is divided in 3 sub-block :

	* VRRP scripts
	* VRRP synchronization group
	* VRRP gratuitous ARP/NA intervals
	* VRRP instance

	2.1. VRRP scripts

	The configuration block looks like :

vrrp_script <STRING> {          # VRRP script declaration
    script <QUOTED_STRING>      # script to run periodically
    interval <INTEGER>          # run the script this every seconds
    timeout <INTEGER>           # script considered failed after 'timeout' seconds
    weight <INTEGER:-254..254>  # adjust priority by this weight
    fall <INTEGER>              # required number of failures for KO switch
    rise <INTEGER>              # required number of successes for OK switch
    user USERNAME [GROUPNAME]	# specify user/group to run script under
    init_fail                   # assume script initially is in failed state
}

The script will be executed periodically, every <interval> seconds. Its exit
code will be recorded for all VRRP instances which monitor it.
Note that the script will only be executed if at least one VRRP instance
monitors.

The default weight equals 0, which means that any VRRP instance monitoring
the script will transition to the fault state after <fall> consecutive failures
of the script. After that, <rise> consecutive successes will cause VRRP instances to
leave the fault state, unless they are also in the fault state due to other scripts
or interfaces that they are tracking.

A positive weight means that <rise> successes will add <weight> to the priority of all
VRRP instances which monitor it. On the opposite, a negative weight will be subtracted
from the initial priority in case of <fall> failures.

	2.2. VRRP synchronization group

	The configuration block looks like :

vrrp_sync_group <STRING> {	# VRRP sync group declaration
    group {			# group of instance to sync together
      <STRING>			#   a
      <STRING>			#       set
      ...			#             of VRRP_Instance string
    }
    global_tracking		# allow sync groups to use weights. In order for this
				# to work, all members of the sync group must track
				# exactly the same interfaces and scripts

				# The username and groupname specify the user and group
				# under which the scripts should be run. If username is
				# specified, the group defaults to the group of the user.
				# If username is not specified, they default to the
				# global script_user and script_group
    notify_master <STRING>|<QUOTED-STRING> [username [groupname]]
				# Script to run during MASTER transit
    notify_backup <STRING>|<QUOTED-STRING> [username [groupname]]
				# Script to run during BACKUP transit
    notify_fault <STRING>|<QUOTED-STRING> [username [groupname]]
				# Script to run during FAULT transit
    notify <STRING>|<QUOTED-STRING> [username [groupname]]
				# Script to run during ANY state transit (1)
    smtp_alert		 # Send email notification during state transit
}

(1) The "notify" script is called AFTER the corresponding notify_* script has
    been called, and is given exactly 4 arguments (the whole string is interpreted
    as a literal filename so don't add parameters!):

    $1 = A string indicating whether it's a "GROUP" or an "INSTANCE"
    $2 = The name of said group or instance
    $3 = The state it's transitioning to ("MASTER", "BACKUP" or "FAULT")
    $4 = The priority value

    $1 and $3 are ALWAYS sent in uppercase, and the possible strings sent are the
    same ones listed above ("GROUP"/"INSTANCE", "MASTER"/"BACKUP"/"FAULT").

Important: for a SYNC group to run reliably, it is vital that all instances in
	   the group are MASTER or that they are all either BACKUP or FAULT. A
	   situation with half instances having higher priority on machine A
	   half others with higher priority on machine B will lead to constant
	   re-elections. For this reason, when instances are grouped, their
	   tracking weights are automatically set to zero, in order to avoid
	   inconsistent priorities across instances.

	2.3. VRRP gratuitous ARP/NA intervals

	This section allows the setting of delays between sending gratuitous ARPs
	and unsolicited neighbour advertisements. This is intended for when an
	upstream switch is unable to handle being flooded with ARPs/NAs.

	Use interface when the limits apply on the single physical interface.
	Use interfaces when a group of interfaces are linked to the same switch
	and the limits apply to the switch as a whole.

	Note: Only one of interface or interfaces should be used per block.

garp_group {
    garp_interval <DECIMAL>		   # Sets the interval between Gratuitous ARP
					   #   (in seconds, resolution microseconds)
    gna_interval <DECIMAL>		   # Sets the default interval between unsolicited NA
					   #   (in seconds, resolution microseconds)
    interface <STRING>			   # The physical interface to which the intervals apply
    interfaces {			   # A list of interfaces across which the delays are
	<STRING>			   #   aggregated.
	<STRING>
	...
    }
}

	If the global vrrp_garp_interval and/or vrrp_gna_interval are set, any
	interfaces that aren't specified in a garp_group will inherit the global
	settings.

	2.4. VRRP instance

	The configuration block looks like :

vrrp_instance <STRING> {		# VRRP instance declaration
    use_vmac [<NAME>]			# Use VRRP Virtual MAC, optional NAME of interface
    version <INTEGER:2..3>              # VRRP version to use
    vmac_xmit_base			# Send/Recv VRRP messages from base
					#  interface instead of VMAC interface
    native_ipv6				# Force instance to use IPv6
					#  when using mixed IPv4&IPv6 conf
    state MASTER|BACKUP			# Start-up default state
    interface <STRING>			# Binding interface
    accept				# Allow a non address-owner to process packets
					# destined to VIPs and eVIPs. This is the default
					# unless strict mode is set.
    no_accept				# Set non-accept mode (default if strict mode)
					#
    track_interface {			# Interfaces state we monitor
      <STRING>
      <STRING>
      <STRING> weight <INTEGER:-254..254>
      ...
    }
    track_script {                     # Scripts state we monitor
      <STRING>
      <STRING> weight <INTEGER:-254..254>
      ...
    }
    dont_track_primary                  # (default unset) ignore VRRP interface faults.
                                        #  useful for cross-connect VRRP config.
    mcast_src_ip <IP ADDRESS>		# src_ip to use into the VRRP packets
    unicast_src_ip <IP ADDRESS>		# src_ip to use into the VRRP packets (alias to mcast_src_ip)
    unicast_peer {			# Do not use multicast, instead send VRRP
      <IP ADDRESS>			#  adverts to following list of ip address
      ...				#  in unicast design fashion
    }

    # The following garp parameters take their defaults from the global config for vrrp_garp_...
    # See their descriptions for the meaning of the parameters.
    garp_master_delay <INTEGER>
    garp_master_repeat <INTEGER>
    garp_lower_priority_delay <INTEGER>
    garp_lower_priority_repeat <INTEGER>
    garp_master_refresh <INTEGER>
    garp_master_refresh_repeat <INTEGER>

    virtual_router_id <INTEGER-1..255>	# VRRP VRID
    priority <INTEGER-1..255>		# VRRP PRIO
    advert_int <FLOAT>			# VRRP Advert interval (use default)

    lower_prio_no_advert		# If a lower priority advert is received, don't
					# don't send another advert. This causes adherence
					# to the RFCs (defaults to global
					# vrrp_lower_priority_dont_send_advert).

    # Note: authentication was removed from the VRRPv2 specification by RFC3768 in 2004.
    #   Use of this option is non-compliant and can cause problems; avoid using if possible,
    #   except when using unicast, when it can be helpful.
    authentication {			# Authentication block
        auth_type PASS|AH		# Simple password or IPSEC AH
        auth_pass <STRING>		# Password string (up to 8 characters)
    }
    virtual_ipaddress {			# VRRP IP addres block
        <IP ADDRESS>/<MASK> brd <IP ADDRESS> dev <STRING> scope <SCOPE> label <LABEL>
        <IP ADDRESS>/<MASK> brd <IP ADDRESS> dev <STRING> scope <SCOPE> label <LABEL>
        ...
    }
    virtual_ipaddress_excluded {       	# VRRP IP excluded from VRRP
        <IP ADDRESS>/<MASK> brd <IP ADDRESS> dev <STRING> scope <SCOPE>	# packets
        <IP ADDRESS>/<MASK> brd <IP ADDRESS> dev <STRING> scope <SCOPE>
        ...
    }
    prompte_secondaries			# Set the promote_secondaries flag on the interface to stop other
					# addresses in the same CIDR being removed when 1 of them is removed
    virtual_routes {			# VRRP virtual routes
					# The syntax is the same as static_routes
    }
    virtual_rules {			# VRRP virtual rules
					# The syntax is the same as static_rules
    }

    nopreempt					# Override VRRP RFC preemption default
    preempt_delay				# Seconds after startup or seeing a lower priority master
						#  until preemption. 0 (default) to 1,000
    strict_mode [<BOOL>]			# See description of global vrrp_strict
						# If vrrp_strict is not specified, it takes the value of vrrp_strict
						# If strict_mode without a parameter is specified, it defaults to on
    debug <LEVEL>				# Debug level. LEVEL is a number in the range 0 to 4.
    notify_master <STRING>|<QUOTED-STRING> [username [groupname]]
						# Same as vrrp_sync_group
    notify_backup <STRING>|<QUOTED-STRING> [username [groupname]]
						# Same as vrrp_sync_group
    notify_fault <STRING>|<QUOTED-STRING> [username [groupname]]
						# Same as vrrp_sync_group
    notify_stop <STRING>|<QUOTED-STRING> [username [groupname]]
						# Script to launch when stopping vrrp
    notify <STRING>|<QUOTED-STRING> [username [groupname]]
						# Same as vrrp_sync_group
    smtp_alert					# Same as vrrp_sync_group
}

SCOPE can take the following values :
	* site
	* link
	* host
	* nowhere
	* global

LABEL is optional and creates a name for the alias. For compatibility with
"ifconfig", it should be of the form <realdev>:<anytext>, for example
eth0:1 for an alias on eth0.

METRIC is optional and specify a route priority.

When a weight is specified in track_interface, instead of setting the vrrp
instance to the FAULT state in case of failure, its priority will be
increased by the weight when the interface is up (for positive weights),
or decreased by the weight's absolute value when the interface is down
(for negative weights). The weight must be comprised between -254 and +254
inclusive. 0 is the default behaviour which means that a failure implies a
FAULT state. The common practice is to use positive weights to count a
limited number of good services so that the server with the highest count
becomes master. Negative weights are better to count unexpected failures
among a high number of interfaces, as it will not saturate even with high
number of interfaces.

The same principle can be applied to track_script entries, except that an
unspecified weight means that the default weight declared in the script
will be used (which itself defaults to 0).


3. LVS configuration

This block is divided in 2 sub-block :

	* Virtual server group
	* Virtual server

	3.1. Virtual server group

	The configuration block looks like :

virtual_server_group <STRING> {
	<IP ADDRESS> <PORT>		# VIP VPORT
	<IP ADDRESS> <PORT>
	...
	<IP ADDRESS RANGE> <PORT>	# VIP range VPORT
	<IP ADDRESS RANGE> <PORT>
	...
	fwmark <INTEGER>		# fwmark
	fwmark <INTEGER>
	...
}

Note:	<IP ADDRESS RANGE> has the form of : XXX.YYY.ZZZ.WWW-VVV, define
	the IP address range starting at WWW and monotonaly incremented by
	one to VVV. Example : 192.168.200.1-10 means .1 to .10 IP addresses.

	3.2. Virtual server

	The configuration block looks like :

	A virtual_server can be either :
	* vip vport declaration
	* fwmark declaration
	* group declaration

virtual_server <IP ADDRESS> <PORT> {	# VS IP/PORT declaration
virtual_server fwmark <INTEGER>    {	# VS fwmark declaration
virtual_server group <STRING>      {	# VS group declaration
    ip_family inet|inet6		# Address family
    delay_loop <INTEGER>		# delay timer for service polling
    lvs_sched rr|wrr|lc|wlc|lblc|sh|dh	# LVS scheduler used
    hashed				# Apply hashing
    flag-1				# Apply scheduler flag 1
    flag-2				# Apply scheduler flag 2
    flag-3				# Apply scheduler flag 3
    sh-port				# Apply sh-port scheduler flag (only for sh scheduler,
					#  same as flag-2 for sh scheduler)
    sh-fallback				# Apply sh-fallback scheduler flag (only for sh scheduler,
					#  same as flag-1 for sh scheduler)
    ops					# Apply One-Packet-Scheduling (only for UDP)
    lvs_method NAT|DR|TUN		# LVS method used
    persistence_engine <STRING>	        # LVS persistence engine name
    persistence_timeout [<INTEGER>]	# LVS persistence timeout, default 6 minutes
    persistence_granularity <NETMASK>	# LVS granularity mask
    protocol TCP|UDP|SCTP               # L4 protocol
    ha_suspend				# If VS IP address is not set, suspend
					#  healthcheckers activity
    virtualhost <STRING>		# VirtualHost string to use for
					#  HTTP_GET or SSL_GET

    # Assume silently all RSs down and healthchecks
    # failed on start. This helps preventing false
    # positive actions on startup. Alpha mode is
    # disabled by default.
    alpha

    # On daemon shutdown, consider quorum and RS
    # down notifiers for execution, where appropriate.
    # Omega mode is disabled by default.
    omega

    # Minimum total weight of all live servers in
    # the pool necessary to operate VS with no
    # quality regression. Defaults to 1.
    quorum <INT>

    # Tolerate this much weight units compared to the
    # nominal quorum, when considering quorum gain
    # or loss. A flap dampener. Defaults to 0.
    hysteresis <INT>

    # Script to launch when quorum is gained.
    quorum_up <STRING>|<QUOTED-STRING>

    # Script to launch when quorum is lost.
    quorum_down <STRING>|<QUOTED-STRING>

    sorry_server <IP ADDRESS> <PORT>	# RS to add to LVS topology when all
					#   realserver are down
    sorry_server_inhibit		# applies inhibit_on_failure behaviour
					# to the preceding sorry_server
					# directive

    real_server <IP ADDRESS> <PORT> {	# RS declaration
        weight <INTEGER>		# weight to use (default: 1)
        inhibit_on_failure		# Set weight to 0 on healthchecker
					#  failure
        notify_up <STRING>|<QUOTED-STRING> # Script to launch when
					   #  healthchecker consider service
					   #  as up.
        notify_down <STRING>|<QUOTED-STRING> # Script to launch when
					     #  healthchecker consider service
					     #  as down.

        HTTP_GET|SSL_GET {		# HTTP and SSL healthcheckers
            url {			# A set of url to test
              path <STRING>		# Path
              digest <STRING>		# Digest computed with genhash
              status_code <INTEGER>	# status code returned into the HTTP
            }                           #   header. I not specified, then any
					#   2xx code is accepted.
            url {
              path <STRING>
              digest <STRING>
              status_code <INTEGER>
            }
            ...
            connect_ip <IP ADDRESS> # IP address to connect
            connect_port <PORT>     # TCP port to connect
            bindto <IP ADDRESS>     # IP address to bind to
            bind_port <PORT>        # TCP port to bind to
            connect_timeout <INTEGER>   # Timeout connection
            fwmark <INTEGER>        # fwmark to set on socket (SO_MARK)
            nb_get_retry <INTEGER>  # number of get retry
            delay_before_retry <INTEGER> # delay before retry
            warmup <INTEGER>        # random delay for maximum N seconds
        }
    }

    real_server <IP ADDRESS> <PORT> {	# Idem
        weight <INTEGER>		# Idem
        inhibit_on_failure		# Idem
        notify_up <STRING>|<QUOTED-STRING> # Idem
        notify_down <STRING>|<QUOTED-STRING> # Idem

        TCP_CHECK {			# TCP healthchecker
            connect_ip <IP ADDRESS> # IP address to connect
            connect_port <PORT>     # TCP port to connect
            bindto <IP ADDRESS>     # IP address to bind to
            bind_port <PORT>        # TCP port to bind to
            connect_timeout <INTEGER>   # Timeout connection
            fwmark <INTEGER>        # fwmark to set on socket (SO_MARK)
            warmup <INTEGER>        # random delay for maximum N seconds
        }
    }

    real_server <IP ADDRESS> <PORT> {	# Idem
        weight <INTEGER>		# Idem
        inhibit_on_failure		# Idem
        notify_up <STRING>|<QUOTED-STRING> # Idem
        notify_down <STRING>|<QUOTED-STRING> # Idem

        SMTP_CHECK {                   # SMTP healthchecker
            connect_ip <IP ADDRESS>     # Optional IP address to connect to
            connect_port <PORT>         # Optional port to connect to
            bindto <IP ADDRESS>         # Optional interface to use to originate the connection
            bind_port <PORT>            # Optional source port to originate the connection from
            connect_timeout <INTEGER>   # Optional per-host connection timeout.
            fwmark <INTEGER>            # Optional fwmark to mark all outgoing checker pakets with
            host {                      # Optional additional host/port to check
                connect_ip <IP ADDRESS> # IP address to connect
                connect_port <PORT>     # TCP port to connect
                bindto <IP ADDRESS>     # IP address to bind to
                bind_port <PORT>        # TCP port to bind to
                connect_timeout <INTEGER>   # Timeout connection
                fwmark <INTEGER>        # fwmark to set on socket (SO_MARK)
            }
            host {
                connect_ip <IP ADDRESS> # IP address to connect
                connect_port <PORT>     # TCP port to connect
                bindto <IP ADDRESS>     # IP address to bind to
                bind_port <PORT>        # TCP port to bind to
                connect_timeout <INTEGER>   # Timeout connection
                fwmark <INTEGER>        # fwmark to set on socket (SO_MARK)
            }
            ...
            connect_timeout <INTEGER>  # Connection and read/write timeout
            warmup <INTEGER>        # random delay for maximum N seconds
            retry <INTEGER>             # Number of times to retry a failed check
            delay_before_retry <INTEGER> # Delay in seconds before retrying
            helo_name <STRING>|<QUOTED-STRING> # Host to use for the HELO request
        }
    }

    real_server <IP ADDRESS> <PORT> {	# Idem
        weight <INTEGER>		# Idem
        inhibit_on_failure		# Idem
        notify_up <STRING>|<QUOTED-STRING> # Idem
        notify_down <STRING>|<QUOTED-STRING> # Idem

        DNS_CHECK {                     # DNS healthchecker
            connect_ip <IP ADDRESS>     # Optional IP address to connect to
            connect_port <PORT>         # Optional port to connect to
            bindto <IP ADDRESS>         # Optional interface to use to originate the connection
            bind_port <PORT>            # Optional source port to originate the connection from
            connect_timeout <INTEGER>   # Optional per-host connection timeout.
            fwmark <INTEGER>            # Optional fwmark to mark all outgoing checker pakets with
            retry <INTEGER>             # Number of times to retry a failed check
            type <STRING>               # DNS query type
            name <STRING>               # Domain name to use for the DNS query
        }
    }

    real_server <IP ADDRESS> <PORT> {	# Idem
        weight <INTEGER>		# Idem
        inhibit_on_failure		# Idem
        notify_up <STRING>|<QUOTED-STRING> # Idem
        notify_down <STRING>|<QUOTED-STRING> # Idem

        MISC_CHECK {				# MISC healthchecker
            misc_path <STRING>|<QUOTED-STRING>	# External system script or program
            misc_timeout <INTEGER>		# Script execution timeout
            warmup <INTEGER>        # random delay for maximum N seconds

            # If set, exit code from healthchecker is used
            # to dynamically adjust the weight as follows:
            #   exit status 0: svc check success, weight
            #     unchanged.
            #   exit status 1: svc check failed.
            #   exit status 2-255: svc check success, weight
            #     changed to 2 less than exit status.
            #   (for example: exit status of 255 would set
            #     weight to 253)
            misc_dynamic
	    user USERNAME [GROUPNAME] # Specify user/group to run script under
        }
    }
}
